from __future__ import print_function

from probability_tests_tools import *

class weight_counter(object):    
    def __init__(self):
        self.weight = 1.0
        self.weight_ln = 0.0
        self.counter = 0
        
    def add(self, w):
        assert w > 0
        self.weight *= w
        self.weight_ln += math.log(w)
        self.counter += 1
        
    def check_sanity(self):
        w1 = self.weight
        w2 = math.exp(self.weight_ln)

        assert abs(w1-w2)/w1 < .0001
    
def generate_smart(conf, prepend = []):
    seat_dist = [0.0]*(conf.state_sz+1)
    
    dist_inx = prep_dist_inx(conf, prepend)

    success_count = 0

    timer = UpdateTime(10)

    all_samples = []
    
    for i in range(conf.max_repeats):
        rt = generate_smart_one(conf, dist_inx, prepend)
        if rt is not None:
            all_samples.append(rt)
            
            sample_inx, st, wt = rt
            seat_dist[st] += wt.weight
            success_count += 1

            if success_count >= conf.max_num_of_samples:
                break

            sm = sum(seat_dist)
            if success_count >= conf.target_sample_total_weight and sm >= conf.target_sample_total_weight:
                break
            
        
        if conf.timed and timer.is_update_time():
            print (str(round(i/conf.max_repeats*100,2)) + "%", end="\n")

    ret = dummy()
    ret.all_samples = all_samples
    ret.seat_dist = seat_dist
    ret.success_count = success_count
    ret.tries = i
    
    return ret

def get_sample_info(sample_inx, conf):
    smpl = [conf.districts[i] for i in sample_inx]
    votes = sum([rt * pop for rt, pop in smpl])
    pop = sum([pop for rt, pop in smpl])

    return smpl, votes, pop
    

def generate_smart_one(conf, dist_inx_, prepend):
    dist_inx = copy.deepcopy(dist_inx_)

    sample_inx = copy.deepcopy(prepend)
    sample_meta = [None] * len(prepend)
    
    assert conf.state_sz > 1

    for i in range(len(prepend), conf.state_sz):
        if i == 0:
            fn = generate_smart_next_pick
        elif i < conf.state_sz - 1:
            fn = generate_smart_next_pick_cut
        else:
            fn = generate_smart_next_pick_last
            
        can_continue = fn(sample_inx, sample_meta, dist_inx, conf)
            
        if not can_continue:
            return None

    smpl, votes, pop = get_sample_info(sample_inx, conf)
    
    smpl_avg = float(votes)/pop

    assert within(smpl_avg, conf.target, conf.margin)
    
    smpl_st = sum([1 for rt, pop in smpl if rt > .5])

    assert len(sample_inx) == len(sample_meta)
    assert len(sample_inx) == conf.state_sz

    # print(sample_meta[3].ratio, sample_meta[3].is_low_cut)

    total_factor = weight_counter()
    
    for pos in range(1, len(sample_inx) - 1):
        if sample_meta[pos] is None or not hasattr(sample_meta[pos], 'filter_fn'):
            continue
        
        affected_count = len(sample_inx) - pos
        filtered_count = 0
        for i in range(pos, len(sample_inx)):
            if i == pos:
                assert not sample_meta[pos].filter_fn(smpl[i])

            if sample_meta[pos].filter_fn(smpl[i]):
                filtered_count += 1

        combinatorics_factor = float(affected_count) / (affected_count - filtered_count)
        adjustment_factor = sample_meta[pos].ratio

        total_factor.add(combinatorics_factor * adjustment_factor)

    total_factor.add(sample_meta[-1].ratio)
    
    return (sample_inx, smpl_st, total_factor)
 
def generate_smart_next_pick_last(sample_inx, sample_meta, dist_inx, conf):
    picks_remain = conf.state_sz - len(sample_inx)
    assert picks_remain == 1

    smpl, vote_now, pop_now = get_sample_info(sample_inx, conf)
    
    pool = []

    for i in dist_inx:
        rt, pop = conf.districts[i]
        vote_tot = vote_now + rt*pop
        pop_tot = pop_now + pop
        final_ratio = float(vote_tot)/pop_tot
        if within(final_ratio, conf.target, conf.margin):
            pool.append(i)
    if len(pool) == 0:
        return False

    meta = dummy()
    meta.ratio = float(len(pool))/len(dist_inx)
    
    i = random.choice(pool)
    dist_inx.remove(i)

    sample_inx.append(i)
    sample_meta.append(meta)

    return True

def generate_smart_next_pick_cut(sample_inx, sample_meta, dist_inx, conf):
    meta = dummy()

    picks_remain = conf.state_sz - len(sample_inx)
    assert len(sample_inx) > 0
    assert picks_remain > 1

    smpl, vote_now, pop_now = get_sample_info(sample_inx, conf)
    ratio_now = float(vote_now)/pop_now
    
    dist_ratios = [conf.districts[i][0] for i in dist_inx]
    dist_pops = [conf.districts[i][1] for i in dist_inx]
    
    min_pop = min(dist_pops)
    max_pop = max(dist_pops)

    if ratio_now > conf.target - conf.margin:
        lt_pop_level = min_pop
    else:
        lt_pop_level = max_pop
        
    if ratio_now < conf.target + conf.margin:
        ht_pop_level = min_pop
    else:
        ht_pop_level = max_pop

    lt = threshold(vote_now, pop_now, picks_remain, lt_pop_level, conf.target - conf.margin)
    ht = threshold(vote_now, pop_now, picks_remain, ht_pop_level, conf.target + conf.margin)

    lt_filter_fn = lambda dist: dist[0] <= lt
    ht_filter_fn = lambda dist: dist[0] >= ht
    
    lt_pool = [i for i in dist_inx if not lt_filter_fn(conf.districts[i])]
    ht_pool = [i for i in dist_inx if not ht_filter_fn(conf.districts[i])]

    lt_filtered_num = len(dist_inx) - len(lt_pool)
    ht_filtered_num = len(dist_inx) - len(ht_pool)
    
    if lt_filtered_num < picks_remain:
        lt_filter_fn = lambda _: False
        lt_pool = dist_inx
        
    if ht_filtered_num < picks_remain:
        ht_filter_fn = lambda _: False
        ht_pool = dist_inx

    if len(lt_pool) < len(ht_pool):
        pool = lt_pool
        meta.filter_fn = lt_filter_fn
    else:
        pool = ht_pool
        meta.filter_fn = ht_filter_fn
        
    meta.ratio = float(len(pool))/len(dist_inx)

    if len(pool) == 0:
        return False
    
    i = random.choice(pool)
    dist_inx.remove(i)

    sample_inx.append(i)
    sample_meta.append(meta)

    return True

def generate_smart_next_pick(sample, sample_meta, dist_inx, conf):
    i = random.choice(dist_inx)
    dist_inx.remove(i)

    sample.append(i)

    sample_meta.append(None)

    return True

def compute_error(arr1, arr2):
    assert len(arr1) == len(arr2)
    sz = len(arr1)
    
    n1 = sum(arr1)
    n2 = sum(arr2)

    if(n2 == 0):
        return 0

    errs = [0]*sz
    for i in range(sz):
        p1 = float(arr1[i])/n1
        p2 = float(arr2[i])/n2

        if p1 == 0:
            assert p2 == 0
        else:
            diff = abs(p1 - p2)
            SD = math.sqrt(p1*(1-p1)/n2)

            errs[i] = diff/SD

    return max(errs)

if __name__ == "__main__":
    conf = dummy()

    conf.country_sz = 30
    conf.state_sz = 5

    conf.district_ratios = [float(i)/(conf.country_sz-1) for i in range(conf.country_sz)]
    conf.district_pop = [random.uniform(5, 10) for i in range(conf.country_sz)]
    conf.districts = list(zip(conf.district_ratios, conf.district_pop))

    conf.target = .10
    conf.margin = .05

    conf.repeats = 1000
    conf.num_of_samples = conf.repeats
    conf.timed = True

    prepend = []

    rnd_repeats = 5
    seat_sz = conf.state_sz + 1

    # st_rn, time_rn = time_fn(generate_random, conf, prepend)
    # (_, cnt), time_sm = time_fn(generate_smart, conf, prepend)

    # print("random time per sample ", time_rn/sum(st_rn))
    # print("smart  time per sample ", time_sm/cnt)


    seat_dist_all = generate_all(conf, prepend)
    actual_sr = success_rate_raw(seat_dist_all, nCr(conf.country_sz - len(prepend), conf.state_sz - len(prepend)))
    print("complete, success rate", per_conv(actual_sr))

    seat_dist_rnds = []
    for i in range(rnd_repeats):
        seat_dist_rnds.append(generate_random(conf, prepend))
        # print(seat_dist_rnds[-1])
        # print('.',end='')
    print()


    seat_dist_rnd_sum = [sum(s[j] for s in seat_dist_rnds) for j in range(seat_sz)]

    print("random, avg success rate", success_rate_err(seat_dist_rnd_sum, conf.repeats*rnd_repeats, actual_sr))

    seat_dist_rnd_errs = [round(compute_error(seat_dist_all, d),1) for d in seat_dist_rnds]
    print ("random errors", seat_dist_rnd_errs)


    #fc = sum(seat_dist_rnd)/sum(seat_dist_all)
    #seat_dist_all = [round(f*fc,1) for f in seat_dist_all]

    # print(seat_dist_all, "\n")

    ret = generate_smart(conf, prepend)

    seat_dist_smt = ret.seat_dist
    cnt = ret.success_count

    print("smart, simulated success rate", success_rate_err(seat_dist_smt, conf.repeats, actual_sr))
    print("smart, actual success rate", success_rate([cnt], conf.repeats))
    print("error ", round(compute_error(seat_dist_all, seat_dist_smt),1))

    # fc = 1#sum(seat_dist_rnd)/sum(seat_dist_smt)
    # print([round(s*fc, 1) for s in seat_dist_smt])
